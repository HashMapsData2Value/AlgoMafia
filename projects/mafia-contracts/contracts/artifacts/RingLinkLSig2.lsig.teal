#pragma version 10
//#pragma mode logicsig
intcblock 2 6 1 3 32
bytecblock 0x 0x424c53313233383147315f584d443a5348412d3235365f535357555f524f5f1f 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0x0030

// This TEAL was generated by TEALScript v0.107.0
// https://github.com/algorandfoundation/TEALScript

// The address of this logic signature is DNYXAU26DVH524GLVUI7S53IEITOUH463XJ4IXYJ35JXH36DPNVMLBRKJ4

b *route_logic

// logic(byte[],byte[],byte[],byte[],byte[],byte[])void
*route_logic:
	// cExpected: byte[]
	pushint 5
	args
	extract 2 0

	// cPrev: byte[]
	pushint 4
	args
	extract 2 0

	// nonce: byte[]
	intc 3 // 3
	args
	extract 2 0

	// keyImage: byte[]
	intc 0 // 2
	args
	extract 2 0

	// pk: byte[]
	intc 2 // 1
	args
	extract 2 0

	// msg: byte[]
	pushint 0
	args
	extract 2 0

	// execute logic(byte[],byte[],byte[],byte[],byte[],byte[])void
	callsub logic
	intc 2 // 1
	return

// logic(msg: bytes, pk: bytes, keyImage: bytes, nonce: bytes, cPrev: bytes, cExpected: bytes): void
//
// logic: challenge
// Produce the challenge, i.e. an individual link in the ring sig verification.
// We mod by order of fr https://github.com/Consensys/gnark-crypto/blob/master/ecc/bn254/fr/element.go#L42
// c_{i+1} = Hs(m || r_{i} * G + c_{i} * K_{i} || r_{i}*Hp(K_{i}) + c_{i} * I) mod |fr|
// @param msg - The message to be signed
// @param pk - The public key relevant to this link.
// @param keyImage - The key image of the signer, required for linkabiltiy to prevent double spending
// @param nonce - The ring sig nonces, in 1 large byte array. The core of the ring sig itself.
// @param cPrev - The input "challenge", or previous challenge in the ring sig verification flow.
// @param cExpected - The expected challenge, to be compared against the calculated challenge.
logic:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 12

	// contracts/RingLinkLSig2.algo.ts:31
	// left = ecAdd(
	//       'BLS12_381g1',
	//       ecScalarMul('BLS12_381g1', hex(BLS12381G1_BASEPOINT_BYTES), nonce),
	//       ecScalarMul('BLS12_381g1', pk, cPrev)
	//     )
	pushbytes 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1
	frame_dig -4 // nonce: bytes
	ec_scalar_mul BLS12_381g1
	frame_dig -2 // pk: bytes
	frame_dig -5 // cPrev: bytes
	ec_scalar_mul BLS12_381g1
	ec_add BLS12_381g1
	frame_bury 0 // left: byte[]

	// contracts/RingLinkLSig2.algo.ts:40
	// zPad = hex(
	//       '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
	//     )
	bytec 2 // 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	frame_bury 1 // zPad: byte[]

	// contracts/RingLinkLSig2.algo.ts:43
	// lIbStr = hex('0030')
	bytec 3 // 0x0030
	frame_bury 2 // lIbStr: byte[]

	// contracts/RingLinkLSig2.algo.ts:44
	// dstPrime = hex('424c53313233383147315f584d443a5348412d3235365f535357555f524f5f1f')
	bytec 1 // 0x424c53313233383147315f584d443a5348412d3235365f535357555f524f5f1f
	frame_bury 3 // dstPrime: byte[]

	// contracts/RingLinkLSig2.algo.ts:45
	// msgPrime = concat(concat(concat(concat(zPad, pk), lIbStr), hex('00')), dstPrime)
	bytec 2 //  zPad: byte[]
	frame_dig -2 // pk: bytes
	concat
	bytec 3 //  lIbStr: byte[]
	concat
	pushbytes 0x00
	concat
	bytec 1 //  dstPrime: byte[]
	concat
	frame_bury 4 // msgPrime: byte[]

	// contracts/RingLinkLSig2.algo.ts:48
	// b0 = sha256(msgPrime)
	frame_dig 4 // msgPrime: byte[]
	sha256
	frame_bury 5 // b0: byte[32]

	// contracts/RingLinkLSig2.algo.ts:50
	// b1 = sha256(concat(concat(b0, hex('01')), dstPrime))
	frame_dig 5 // b0: byte[32]
	pushbytes 0x01
	concat
	bytec 1 //  dstPrime: byte[]
	concat
	sha256
	frame_bury 6 // b1: byte[32]

	// contracts/RingLinkLSig2.algo.ts:52
	// b2 = sha256(concat(concat(bitwiseXor(b0, b1), hex('02')), dstPrime))
	frame_dig 5 // b0: byte[32]
	frame_dig 6 // b1: byte[32]
	b^
	pushbytes 0x02
	concat
	bytec 1 //  dstPrime: byte[]
	concat
	sha256
	frame_bury 7 // b2: byte[32]

	// contracts/RingLinkLSig2.algo.ts:55
	// uniformBytes = concat(extract3(b1, 0, 32), extract3(b2, 0, 16))
	frame_dig 6 // b1: byte[32]
	extract 0 32
	frame_dig 7 // b2: byte[32]
	extract 0 16
	concat
	frame_bury 8 // uniformBytes: byte[]

	// contracts/RingLinkLSig2.algo.ts:58
	// fpElement = btobigint(uniformBytes) % btobigint(hex(BLS12381_FIELD_MODULUS_HEX))
	frame_dig 8 // uniformBytes: byte[]
	pushbytes 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
	b%
	frame_bury 9 // fpElement: bigint

	// contracts/RingLinkLSig2.algo.ts:61
	// hp2p = ecMapTo('BLS12_381g1', rawBytes(fpElement))
	frame_dig 9 // fpElement: bigint
	ec_map_to BLS12_381g1
	frame_bury 10 // hp2p: byte[]

	// contracts/RingLinkLSig2.algo.ts:67
	// right = ecAdd(
	//       'BLS12_381g1',
	//       ecScalarMul('BLS12_381g1', hp2p, nonce),
	//       ecScalarMul('BLS12_381g1', keyImage, cPrev)
	//     )
	frame_dig 10 // hp2p: byte[]
	frame_dig -4 // nonce: bytes
	ec_scalar_mul BLS12_381g1
	frame_dig -3 // keyImage: bytes
	frame_dig -5 // cPrev: bytes
	ec_scalar_mul BLS12_381g1
	ec_add BLS12_381g1
	frame_bury 11 // right: byte[]

	// contracts/RingLinkLSig2.algo.ts:77
	// h = rawBytes(btobigint(sha256(concat(concat(msg, left), right))) % btobigint(hex(BLS12381_CURVE_ORDER_HEX)))
	frame_dig -1 // msg: bytes
	frame_dig 0 // left: byte[]
	concat
	frame_dig 11 // right: byte[]
	concat
	sha256
	pushbytes 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
	b%
	frame_bury 12 // h: byte[]

	// contracts/RingLinkLSig2.algo.ts:79
	// assert(btobigint(h) === btobigint(cExpected))
	frame_dig 12 // h: byte[]
	frame_dig -6 // cExpected: bytes
	b==
	assert

	// contracts/RingLinkLSig2.algo.ts:81
	// assert(this.txnGroup[this.txn.groupIndex + RING_SIG_LINKS_AMNT - i].applicationArgs[1] === rawBytes(msg))
	txn GroupIndex
	intc 1 // 6
	+
	intc 0 // 2
	-
	gtxns ApplicationArgs 1
	frame_dig -1 // msg: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	==
	assert

	// contracts/RingLinkLSig2.algo.ts:82
	// assert(
	//       extract3(
	//         this.txnGroup[this.txn.groupIndex + RING_SIG_LINKS_AMNT - i].applicationArgs[2],
	//         2 + i * BLS12381G1_LENGTH,
	//         BLS12381G1_LENGTH
	//       ) === pk
	//     )
	txn GroupIndex
	intc 1 // 6
	+
	intc 0 // 2
	-
	gtxns ApplicationArgs 2
	extract 194 96
	frame_dig -2 // pk: bytes
	==
	assert

	// contracts/RingLinkLSig2.algo.ts:89
	// assert(this.txnGroup[this.txn.groupIndex + RING_SIG_LINKS_AMNT - i].applicationArgs[3] === rawBytes(keyImage))
	txn GroupIndex
	intc 1 // 6
	+
	intc 0 // 2
	-
	gtxns ApplicationArgs 3
	frame_dig -3 // keyImage: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	==
	assert

	// contracts/RingLinkLSig2.algo.ts:90
	// assert(
	//       extract3(
	//         this.txnGroup[this.txn.groupIndex + RING_SIG_LINKS_AMNT - i].applicationArgs[4],
	//         2 + (i + 1) * RING_SIG_NONCE_LENGTH,
	//         RING_SIG_NONCE_LENGTH
	//       ) === nonce
	//     )
	txn GroupIndex
	intc 1 // 6
	+
	intc 0 // 2
	-
	gtxns ApplicationArgs 4
	extract 98 32
	frame_dig -4 // nonce: bytes
	==
	assert

	// contracts/RingLinkLSig2.algo.ts:97
	// assert(
	//       extract3(
	//         this.txnGroup[this.txn.groupIndex + RING_SIG_LINKS_AMNT - i].applicationArgs[5],
	//         2 + i * RING_SIG_CHALL_LENGTH,
	//         RING_SIG_CHALL_LENGTH
	//       ) === cPrev
	//     )
	txn GroupIndex
	intc 1 // 6
	+
	intc 0 // 2
	-
	gtxns ApplicationArgs 5
	extract 66 32
	frame_dig -5 // cPrev: bytes
	==
	assert

	// contracts/RingLinkLSig2.algo.ts:104
	// assert(
	//       extract3(
	//         this.txnGroup[this.txn.groupIndex + RING_SIG_LINKS_AMNT - i].applicationArgs[5],
	//         2 + ((i + 1) % 6) * RING_SIG_CHALL_LENGTH,
	//         RING_SIG_CHALL_LENGTH
	//       ) === cExpected
	//     )
	txn GroupIndex
	intc 1 // 6
	+
	intc 0 // 2
	-
	gtxns ApplicationArgs 5
	intc 0 // 2
	intc 3 // 3
	intc 1 // 6
	%
	intc 4 // 32
	*
	+
	intc 4 // 32
	extract3
	frame_dig -6 // cExpected: bytes
	==
	assert
	retsub